(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react-reconciler"));
	else if(typeof define === 'function' && define.amd)
		define("ReactBabylon3D", ["react-reconciler"], factory);
	else if(typeof exports === 'object')
		exports["ReactBabylon3D"] = factory(require("react-reconciler"));
	else
		root["ReactBabylon3D"] = factory(root["react-reconciler"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_5__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var setters = {
    property: function property(propName) {
        var property = function property(component, value) {
            return component[propName] = value;
        };
        return property;
    },
    propertyFromComponent: function propertyFromComponent(propName) {
        var propertyFromComponent = function propertyFromComponent(component, value) {
            return component[propName] = value ? value.getComponent() : undefined;
        };
        return propertyFromComponent;
    },
    setFloat: function setFloat(propName) {
        var setFloat = function setFloat(component, value) {
            return component.setFloat(propName, value);
        };
        return setFloat;
    },
    setVector4: function setVector4(propName) {
        var setVector4 = function setVector4(component, value) {
            return component.setVector4(propName, value);
        };
        return setVector4;
    },
    setTexture: function setTexture(propName) {
        var setTexture = function setTexture(component, value) {
            var newValue = value && value.getComponent ? value.getComponent() : value;
            component.setTexture(propName, newValue);
        };
        return setTexture;
    },
    apply: function apply(component, value) {
        return value(component);
    }
};

module.exports = setters;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

var vector3 = function vector3(_ref, value) {
    var BABYLON = _ref.BABYLON;
    return new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(value)))();
};
var vector4 = function vector4(_ref2, value) {
    var BABYLON = _ref2.BABYLON;
    return new (Function.prototype.bind.apply(BABYLON.Vector4, [null].concat(value)))();
};

var component = function component(context, value, prevReturned) {
    if (!value) {
        if (prevReturned) {
            prevReturned.dispose();
        }

        return null;
    }

    var type = value.type,
        props = value.props;


    if (prevReturned) {
        prevReturned.updateProps(props);
        return prevReturned;
    }

    if (!context.elements.byType[type]) {
        context.logger.warn("element <" + type + "> not found.");
        return;
    }

    return context.elements.byType[type](context, props);
};
component.needLastReturned = true;

var transformers = {
    vector3: vector3,
    vector4: vector4,
    component: component
};

module.exports = transformers;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var disposers = {
    component: function component(_component, lastValue, setter) {
        if (!lastValue) {
            return;
        }
        setter(_component, undefined);
        lastValue.dispose();
    }
};

module.exports = disposers;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(4),
    Node = _require.Node,
    babylonJSRenderer = _require.babylonJSRenderer;

var componentManager = __webpack_require__(8);
var elements = __webpack_require__(9);

var createRenderer = function createRenderer(_ref) {
    var BABYLON = _ref.BABYLON,
        canvas = _ref.canvas;

    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);
    var rootNode = new Node("root", {
        BABYLON: BABYLON,
        canvas: canvas,
        componentManager: componentManager.create(),
        elements: elements,
        engine: engine,
        scene: scene,
        logger: console
    });

    var rootContainer = babylonJSRenderer.createContainer(rootNode);

    var startLoop = function () {
        var loopStarted = false;
        return function () {
            if (!loopStarted) {
                loopStarted = true;
                engine.runRenderLoop(function () {
                    return scene.render();
                });
            }
        };
    }();

    var render = function render(Component) {
        babylonJSRenderer.updateContainer(Component, rootContainer, null, function () {
            return startLoop();
        });
    };

    var dispose = function dispose() {};

    return {
        render: render,
        dispose: dispose
    };
};

module.exports = { createRenderer: createRenderer, elements: elements };

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var ReactFiberReconciler = __webpack_require__(5);
var BabylonjsRenderer = __webpack_require__(6);
var Node = __webpack_require__(7);
var logger = { debug: function debug() {} };

var babylonJSRenderer = ReactFiberReconciler(BabylonjsRenderer({ Node: Node, logger: logger }));

babylonJSRenderer.injectIntoDevTools({
    bundleType: 0, // 0 for PROD, 1 for DEV
    version: "0.2.0", // version for your renderer
    rendererPackageName: "react-babylonjs-3d" // package name
});

module.exports = {
    babylonJSRenderer: babylonJSRenderer,
    Node: Node
};

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 1. evetns
// 1.1 warning message event doesn't exist
// 1.2 not recreate the component if the handler hasn't changed
// 2. compose properties
// 3. re-creatiing babylon component?
// 3.1 as it for now just throws an Error

// const babylonjsFactoryComponent = require("./babylonjs-factory-component");
// const Node = require("./node");

var ErrorNotImplemented = function (_Error) {
    _inherits(ErrorNotImplemented, _Error);

    function ErrorNotImplemented() {
        _classCallCheck(this, ErrorNotImplemented);

        return _possibleConstructorReturn(this, _Error.apply(this, arguments));
    }

    return ErrorNotImplemented;
}(Error);

var _noop = function _noop() {
    return function () {};
};
var _notImplemented = function _notImplemented(name) {
    return function () {
        throw new ErrorNotImplemented(name);
    };
};

var createInstance = function createInstance(_ref) {
    var Node = _ref.Node;
    return function (type /* : string */
    , props /* : Props */
    , rootContainerInstance /* : Container */
    , hostContext /* : {} */
    , // eslint-disable-next-line no-unused-vars
    internalInstanceHandle /* : Object */ /* : Instance */
    ) {
        var node = new Node(type);

        if (rootContainerInstance.props.elements.byType[type]) {
            node.cmp = rootContainerInstance.props.elements.byType[type](hostContext, props);
        }

        return node;
    };
};

var getPublicInstance = function getPublicInstance(instance) {
    return instance;
};

var appendChild = function appendChild(parentInstance /* : Instance  | Container*/
, child /* : Instance | TextInstance */ /* : void */
) {
    return parentInstance.appendChild(child);
};

var removeChild = function removeChild(parentInstance /* : Instance */
, child /* : void */ /* : Instance  | TextInstance*/
) {
    return parentInstance.removeChild(child);
};

var getRootHostContext = function getRootHostContext(container) {
    return container.props;
};

var getChildHostContext = function getChildHostContext(parentContext, type /* : string */
, rootContainer) {
    return Object.assign({}, parentContext, { type: type, rootContainer: rootContainer });
};

var Mutation = function Mutation() {
    return (/*{ logger }*/{
            appendChild: appendChild,
            removeChild: removeChild,
            commitMount: function commitMount(instance /* : Instance */
            , type /* : string */
            , newProps /* : Props */
            , internalInstanceHandle /* : Object */
            ) /* : void */{},
            commitUpdate: function commitUpdate(instance /* : Instance */
            , updatePayload /* : Object */
            , type /* : string */
            , oldProps /* : Props */
            , newProps /* : Props */
            , internalInstanceHandle /* : Object */
            ) /* : void */{
                instance.cmp.updateProps(updatePayload);
            },
            appendChildToContainer: function appendChildToContainer(parentInstance /* : Container */
            , child /* : Instance | TextInstance*/
            ) /* : void */{},
            insertBefore: function insertBefore(parentInstance /* : Instance */
            , child /* : Instance | TextInstance*/
            , beforeChild /* : Instance | TextInstance*/
            ) // eslint-disable-next-line no-unused-vars
            /* : void */{
                // noop
            },
            insertInContainerBefore: function insertInContainerBefore(parentInstance /* : Container */
            , child /* : Instance  | TextInstance*/
            , beforeChild /* : Instance | TextInstance*/
            ) /* : void */{},
            removeChildFromContainer: function removeChildFromContainer(parentInstance /* : Container */
            , child /* : Instance  | TextInstance*/
            ) /* : void */{}
        }
    );
};

var BabylonJSRenderer = function BabylonJSRenderer(opts) {
    return {
        now: function now() {
            return Date.now();
        },
        useSyncScheduling: true,
        mutation: Mutation(opts),
        getRootHostContext: getRootHostContext,
        getPublicInstance: getPublicInstance,
        createInstance: createInstance(opts),
        getChildHostContext: getChildHostContext,

        // at this stage all children were created and already had the `finalizeInitialChildren` executed
        // 1. when a component's created it's possible to set some default values
        // 2. also some actions, such as setting focus
        // 3. if it returns true, eventually it will trigger a commitMount
        // 4. another thing(if not the most important) you should set the properties in your component
        finalizeInitialChildren: function finalizeInitialChildren(instance /* : Instance */
        , type /* : string */
        , props /* : Props */
        , rootContainerInstance /* : Container */
        ) /* : boolean */{
            return true;
        },

        appendInitialChild: appendChild,

        // decides if there is any update to be done
        // if there is no change to apply, then just returns null
        // otherwise to make your life easier, calculate what needs to be changed and return it
        // it's result will be passed to `mutation.commitUpdate` as `updatePayload` (2nd parameter)
        prepareUpdate: function prepareUpdate(instance /* : Instance */
        , type /* : string */
        , oldProps /* : Props */
        , newProps /* : Props */
        , rootContainerInstance /* : Container */
        , hostContext /* : {} */
        ) /* : null  | Object*/{
            // if (arePropsEqual(oldProps, newProps)) {
            //     return newProps;
            // }
            return newProps;
        },

        // **********************************
        // hooks whenever an update happens
        // **********************************
        prepareForCommit: _noop("prepareForCommit"),
        resetAfterCommit: _noop("resetAfterCommit"),

        // **********************************
        // as it doesn't support pure text content....
        // **********************************
        // eslint-disable-next-line no-unused-vars
        shouldSetTextContent: function shouldSetTextContent(type /* : string */
        , props /* : Props*/
        ) /*:  boolean*/{
            return false;
        },

        // eslint-disable-next-line no-unused-vars
        resetTextContent: _notImplemented("resetTextContent"),
        // (instance /* : Instance*/) /*:  void*/ {
        //     throw new ErrorNotImplemented();
        // },

        createTextInstance: _notImplemented("createTextInstance"),
        // (
        //     text,
        //     rootContainerInstance,
        //     hostContext,
        //     // eslint-disable-next-line no-unused-vars
        //     internalInstanceHandle
        // ) {
        //     throw new ErrorNotImplemented();
        // },

        commitTextUpdate: _notImplemented("commitTextUpdate")
        // (
        //     textInstance /* : TextInstance */,
        //     oldText /* : string */,
        //     // eslint-disable-next-line no-unused-vars
        //     newText /* : string */
        // ) /* : void */ {
        //     throw new ErrorNotImplemented();
        // },
        // **********************************
        // **********************************
    };
};

module.exports = BabylonJSRenderer;

// // eslint-disable-next-line no-unused-vars
// function processProps(
//     instance /* : number */,
//     props /* : Props*/
// ) /*:  Object*/ {
//     const propsPayload = {};
//     for (let key in props) {
//         if (key === "children") {
//             // Skip special case.
//             continue;
//         }
//         let value = props[key];
//         if (typeof value === "function") {
//             value = {
//                 style: "rt-event",
//                 event: key,
//                 tag: instance,
//             };
//         }
//         propsPayload[key] = value;
//     }
//     return propsPayload;
// }

// // eslint-disable-next-line no-unused-vars
// function arePropsEqual(
//     oldProps /* : Props */,
//     newProps /* : Props*/
// ) /*:  boolean*/ {
//     for (let key in newProps) {
//         if (key === "children") {
//             // Skip special case.
//             continue;
//         }

//         if (newProps[key] !== oldProps[key]) {
//             return false;
//         }
//     }

//     for (let key in oldProps) {
//         if (key === "children") {
//             // Skip special case.
//             continue;
//         }
//         if (!(key in newProps)) {
//             return false;
//         }
//     }
//     return true;
// }

/***/ }),
/* 7 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function Node(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // Stores all the children
    if (typeof type !== "string") {
        throw new Error("invalid type of Node [" + (typeof type === "undefined" ? "undefined" : _typeof(type)) + "]");
    }

    if ((typeof props === "undefined" ? "undefined" : _typeof(props)) !== "object") {
        throw new Error("invalid type of props [" + (typeof props === "undefined" ? "undefined" : _typeof(props)) + "]");
    }

    this.type = type;
    this.props = props;
    this.children = [];

    this.appendChild = function (child) {
        this.children.push(child);
        child.parent = this;
    };

    this.removeChild = function (child) {
        var index = this.children.indexOf(child);
        this.children.splice(index, 1);

        while (child.children.length > 0) {
            child.removeChild(child.children[child.children.length - 1]);
        }

        if (child.dispose) {
            child.dispose();
        }
    };

    this.dispose = function () {
        if (this.cmp && this.cmp.dispose) {
            this.cmp.dispose();
        }
    };
}

module.exports = Node;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var ComponentManager = function ComponentManager() {
    var _lastId = 0;
    var _cache = {};
    var validateId = function validateId(componentId) {
        if (!componentId) {
            throw new Error("No id was provided");
        }

        var id = parseInt(componentId);

        if (!id || id > _lastId) {
            throw new Error("Invalid id");
        }
    };

    var newId = function newId() {
        return (++_lastId).toString();
    };
    var save = function save(componentId, component) {
        validateId(componentId);
        if (component) {
            _cache[componentId] = component;
        } else {
            delete _cache[componentId];
        }
    };
    var get = function get(componentId) {
        validateId(componentId);
        return _cache[componentId];
    };

    return {
        newId: newId,
        save: save,
        get: get
    };
};

module.exports = { create: ComponentManager };

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(10),
    compose = _require.compose;

var propertyUpdater = __webpack_require__(12);

var styles = {
    standardMaterial: function standardMaterial(props) {
        return { type: "standardMaterial", props: props };
    },
    shaderMaterial: function shaderMaterial(props) {
        return { type: "shaderMaterial", props: props };
    },
    texture: function texture(props) {
        return { type: "texture", props: props };
    },
    cubeTexture: function cubeTexture(props) {
        return { type: "cubeTexture", props: props };
    }
};

var fromPairs = function fromPairs(arr) {
    return arr.reduce(function (obj, _ref) {
        var _Object$assign;

        var key = _ref[0],
            value = _ref[1];
        return Object.assign(obj, (_Object$assign = {}, _Object$assign[key] = value, _Object$assign));
    }, {});
};

var byType = fromPairs([__webpack_require__(13), __webpack_require__(14), __webpack_require__(15), __webpack_require__(16), __webpack_require__(17), __webpack_require__(18), __webpack_require__(19), __webpack_require__(20), __webpack_require__(21), __webpack_require__(22)].map(function (_ref2) {
    var type = _ref2.type,
        props = _ref2.props,
        createComponent = _ref2.createComponent;
    return [type, compose(type, { props: props, createComponent: createComponent }, propertyUpdater(type, props))];
}));

module.exports = { styles: styles, byType: byType };

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(11),
    clone = _require.clone,
    equals = _require.equals;

var shouldCreateNewComponent = function shouldCreateNewComponent(propsDefinitions) {
    var defs = Object.keys(propsDefinitions).filter(function (def) {
        return propsDefinitions[def].newComponentRequired;
    }).reduce(function (acc, key) {
        var _Object$assign;

        return Object.assign(acc, (_Object$assign = {}, _Object$assign[key] = true, _Object$assign));
    }, {});

    return function (props, currentProps) {
        for (var prop in props) {
            if (defs[prop] && !equals(currentProps[prop], props[prop])) {
                return true;
            }
        }
        return false;
    };
};

var validateComponent = function validateComponent(type, definition, updater) {
    if (!type) {
        throw new Error("Component's type is required");
    }

    if (!definition) {
        throw new Error("Component's definition is required");
    }

    if (!definition.createComponent) {
        throw new Error("Component's definition's must have a property createComponent");
    }

    if (!updater) {
        throw new Error("Updater is required");
    }
};

var compose = function compose(type, definition, updater) {
    validateComponent(type, definition, updater);

    var definitionProps = Object.assign({}, definition.props);

    var requireNewComponent = shouldCreateNewComponent(definitionProps);

    var creator = function creator(context, providedProps) {
        var props = clone(providedProps);

        var componentId = void 0;
        var baseComponent = void 0;

        var getComponent = function getComponent() {
            return baseComponent;
        };
        var internalCreateComponent = function internalCreateComponent() {
            var tmpProps = clone(props);
            if (baseComponent) {
                baseComponent.dispose();
            }
            baseComponent = definition.createComponent(context, tmpProps);
        };

        internalCreateComponent();

        var instance = {
            getComponent: getComponent,
            updateProps: function updateProps(values) {
                var createNewComponent = requireNewComponent(values, props);

                Object.assign(props, clone(values));

                if (createNewComponent === true) {
                    internalCreateComponent();
                    return;
                }
                updater(context, getComponent(), clone(values), componentId);
            },
            dispose: function dispose() {
                updater.dispose(context, getComponent(), props, componentId);
                getComponent().dispose();
            }
        };

        componentId = context.componentManager.newId(instance);
        updater(context, getComponent(), clone(props), componentId);
        return instance;
    };

    creator.type = type;

    return creator;
};

module.exports = { compose: compose };

/***/ }),
/* 11 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var equals = function equals(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }

    if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === "object" && (typeof b === "undefined" ? "undefined" : _typeof(b)) === "object") {
        for (var key in a) {
            if (equals(a[key], b[key]) === false) {
                return false;
            }
        }

        for (var _key in b) {
            if (equals(a[_key], b[_key]) === false) {
                return false;
            }
        }

        return true;
    }

    return a === b;
};

var clone = function clone(obj) {
    if (Array.isArray(obj)) {
        return obj.slice(0);
    }

    if (obj instanceof Date) {
        return new Date(obj);
    }

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object") {
        return obj.valueOf();
    }

    var newObj = Object.assign({}, obj);

    for (var key in obj) {
        newObj[key] = clone(obj[key]);
    }

    return newObj;
};

module.exports = { clone: clone, equals: equals };

/***/ }),
/* 12 */
/***/ (function(module, exports) {

var getValue = function getValue(transformer, propValue, propName, componentId, context) {
    if (!transformer) {
        return propValue;
    }

    if (!transformer.needLastReturned) {
        return transformer(context, propValue);
    }

    var keyComponent = componentId + "::" + propName;
    var value = transformer(context, propValue, context.componentManager.get(keyComponent));
    context.componentManager.save(keyComponent, value);
    return value;
};

var propertyUpdater = function propertyUpdater(type, propsDefinition) {
    var updater = function updater(context, component, props, componentId) {
        return Object.keys(props).forEach(function (propName) {
            if (!propsDefinition[propName]) {
                context.logger.warn("property [" + propName + "] is not defined for the component <" + type + ">");
                return;
            }

            if (propsDefinition[propName].newComponentRequired === true) {
                return;
            }

            var _propsDefinition$prop = propsDefinition[propName],
                transformer = _propsDefinition$prop.transformer,
                setter = _propsDefinition$prop.setter;


            var value = getValue(transformer, props[propName], propName, componentId, context);

            setter(component, value);
        });
    };

    updater.dispose = function (context, component, props, componentId) {
        Object.keys(propsDefinition).forEach(function (propName) {
            var prop = propsDefinition[propName];
            if (prop.dispose) {
                var keyComponent = componentId + "::" + propName;
                prop.dispose(component, context.componentManager.get(keyComponent), propsDefinition[propName].setter);
            }
        });
    };
    return updater;
};

module.exports = propertyUpdater;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var transformers = __webpack_require__(1);
var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref) {
    var scene = _ref.scene;

    return scene;
};

var props = {
    clearColor: {
        setter: setters.property("clearColor"),
        transformer: transformers.vector3
    },
    ambientColor: {
        setter: setters.property("ambientColor"),
        transformer: transformers.vector3
    }

};

var scene = { type: "scene", createComponent: createComponent, props: props };

module.exports = scene;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var disposers = __webpack_require__(2);
var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.Mesh.CreateBox(props.name, props.size, scene);
    return component;
};

var props = {
    size: { newComponentRequired: true },
    infiniteDistance: {
        setter: setters.property("infiniteDistance")
    },
    width: { setter: setters.property("width") },
    height: { setter: setters.property("height") },
    subdivisions: { setter: setters.property("subdivisions") },
    material: {
        setter: setters.propertyFromComponent("material"),
        transformer: transformers.component,
        dispose: disposers.component
    },
    position: {
        setter: setters.property("position"),
        transform: transformers.vector3
    }
};

var box = { type: "box", createComponent: createComponent, props: props };
module.exports = box;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var disposers = __webpack_require__(2);
var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = BABYLON.Mesh.CreateGround(props.name, props.width, props.height, props.subdivisions, scene);
    return component;
};

var props = {
    width: { newComponentRequired: true },
    height: { newComponentRequired: true },
    subdivisions: { newComponentRequired: true },
    material: {
        setter: setters.propertyFromComponent("material"),
        transformer: transformers.component,
        dispose: disposers.component
    },

    position: {
        setter: setters.property("position"),
        transformer: transformers.vector3
    }
};

var ground = { type: "ground", createComponent: createComponent, props: props };
module.exports = ground;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var disposers = __webpack_require__(2);
var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = BABYLON.Mesh.CreateSphere(props.name, props.segments, props.diameter, scene);
    return component;
};

var props = {
    segments: { newComponentRequired: true },
    diameter: { newComponentRequired: true },
    infiniteDistance: { setter: setters.property("infiniteDistance") },
    position: {
        setter: setters.property("position"),
        transformer: transformers.vector3
    },
    material: {
        setter: setters.propertyFromComponent("material"),
        transformer: transformers.component,
        dispose: disposers.component
    }
};

var sphere = { type: "sphere", createComponent: createComponent, props: props };
module.exports = sphere;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var transformers = __webpack_require__(1);
var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.FreeCamera(props.name, new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(props.position)))(), scene);
    scene.activeCamera = component;
    if (props.defaultTarget) {
        component.setTarget(new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(props.defaultTarget)))());
    }
    return component;
};

var props = {
    position: { newComponentRequired: true },
    defaultTarget: { newComponentRequired: true },
    target: {
        setter: function setter(component, value) {
            return component.setTarget(value);
        },
        transformer: transformers.vector3
    },
    attachControl: {
        setter: setters.apply,
        transformer: function transformer(context, value) {
            if (value === true) {
                return function (component) {
                    return component.attachControl(context.canvas, true);
                };
            }
            return function (component) {
                return component.detachControl(context.canvas);
            };
        }
    }
};

var freeCamera = { type: "freeCamera", createComponent: createComponent, props: props };

module.exports = freeCamera;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.HemisphericLight(props.name, new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(props.target)))(), scene);
    return component;
};

var props = {
    target: { newComponentRequired: true },
    intensity: { setter: setters.property("intensity") }
};

var hemisphericLight = { type: "hemisphericLight", createComponent: createComponent, props: props };
module.exports = hemisphericLight;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var disposers = __webpack_require__(2);
var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.ShaderMaterial(props.name, scene, props.shaderPath, {
        attributes: Array.from(props.attributes),
        uniforms: Array.from(props.uniforms)
    });
    return component;
};

var props = {
    shaderPath: { newComponentRequired: true },
    attributes: { newComponentRequired: true },
    uniforms: { newComponentRequired: true },

    diffuseColor: {
        setter: setters.property("diffuseColor"),
        transformer: transformers.vector3
    },
    backFaceCulling: { setter: setters.property("backFaceCulling") },

    width: { setter: setters.setFloat("width") },
    height: { setter: setters.setFloat("height") },
    boxSize: { setter: setters.setFloat("boxSize") },
    edgeColor: {
        setter: setters.setVector4("edgeColor"),
        transformer: transformers.vector4
    },
    hue: {
        setter: setters.setVector4("hue"),
        transformer: transformers.vector4
    },

    tileTex: {
        setter: setters.setTexture("tileTex"),
        transformer: transformers.component,
        dispose: disposers.component
    }
};

var shaderMaterial = {
    superTypes: ["material"],
    type: "shaderMaterial",
    createComponent: createComponent,
    props: props
};

module.exports = shaderMaterial;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var disposers = __webpack_require__(2);
var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.StandardMaterial(props.name, scene);
    return component;
};

var props = {
    backFaceCulling: { setter: setters.property("backFaceCulling") },
    diffuseColor: {
        setter: setters.property("diffuseColor"),
        transformer: transformers.vector3
    },

    specularColor: {
        setter: setters.property("specularColor"),
        transformer: transformers.vector3
    },
    emissiveColor: {
        setter: setters.property("emissiveColor"),
        transformer: transformers.vector3
    },
    ambientColor: {
        setter: setters.property("ambientColor"),
        transformer: transformers.vector3
    },

    reflectionTexture: {
        setter: setters.propertyFromComponent("reflectionTexture"),
        transformer: transformers.component,
        dispose: disposers.component
    }
};

var standardMaterial = {
    superTypes: ["material"],
    type: "standardMaterial",
    createComponent: createComponent,
    props: props
};

module.exports = standardMaterial;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.Texture(props.url, scene);
    return component;
};

var props = {
    url: { newComponentRequired: true }
};

var texture = {
    superTypes: ["texture"],
    type: "texture",
    createComponent: createComponent,
    props: props
};

module.exports = texture;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.CubeTexture(props.url, scene);
    return component;
};

var props = {
    url: { newComponentRequired: true },
    coordinatesMode: {
        setter: setters.property("coordinatesMode")
    }
};

var cubeTexture = {
    superTypes: ["cubeTexture"],
    type: "cubeTexture",
    createComponent: createComponent,
    props: props
};

module.exports = cubeTexture;

/***/ })
/******/ ]);
});
//# sourceMappingURL=react-babylon-3d.min.js.map