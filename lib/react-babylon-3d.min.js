(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react-reconciler"));
	else if(typeof define === 'function' && define.amd)
		define("ReactBabylon3D", ["react-reconciler"], factory);
	else if(typeof exports === 'object')
		exports["ReactBabylon3D"] = factory(require("react-reconciler"));
	else
		root["ReactBabylon3D"] = factory(root["react-reconciler"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var setters = {
    property: function property(propName) {
        var property = function property(component, value) {
            return component[propName] = value;
        };
        return property;
    },
    propertyFromComponent: function propertyFromComponent(propName) {
        var propertyFromComponent = function propertyFromComponent(component, value) {
            return component[propName] = value ? value.getComponent() : undefined;
        };
        return propertyFromComponent;
    },
    setFloat: function setFloat(propName) {
        var setFloat = function setFloat(component, value) {
            return component.setFloat(propName, value);
        };
        return setFloat;
    },
    setVector4: function setVector4(propName) {
        var setVector4 = function setVector4(component, value) {
            return component.setVector4(propName, value);
        };
        return setVector4;
    },
    setTexture: function setTexture(propName) {
        var setTexture = function setTexture(component, value) {
            var newValue = value && value.getComponent ? value.getComponent() : value;
            component.setTexture(propName, newValue);
        };
        return setTexture;
    },
    apply: function apply(component, value) {
        return value(component);
    }
};

module.exports = setters;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

var vector3 = function vector3(_ref, value) {
    var BABYLON = _ref.BABYLON;
    return new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(value)))();
};
var vector4 = function vector4(_ref2, value) {
    var BABYLON = _ref2.BABYLON;
    return new (Function.prototype.bind.apply(BABYLON.Vector4, [null].concat(value)))();
};

var component = function component(context, value, prevReturned) {
    if (!value) {
        if (prevReturned) {
            prevReturned.dispose();
        }

        return null;
    }

    var type = value.type,
        props = value.props;


    if (prevReturned) {
        prevReturned.updateProps(props);
        return prevReturned;
    }

    if (!context.elements.byType[type]) {
        context.logger.warn("element <" + type + "> not found.");
        return;
    }

    return context.elements.byType[type](context, props);
};
component.needLastReturned = true;

var transformers = {
    vector3: vector3,
    vector4: vector4,
    component: component
};

module.exports = transformers;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(3),
    Node = _require.Node,
    BabylonJSRenderer = _require.BabylonJSRenderer;

var componentManager = __webpack_require__(7);
var elements = __webpack_require__(8);

var createRenderer = function createRenderer(_ref) {
    var BABYLON = _ref.BABYLON,
        canvas = _ref.canvas;

    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);
    var rootNode = new Node(undefined, {
        BABYLON: BABYLON,
        canvas: canvas,
        componentManager: componentManager.create(),
        elements: elements,
        engine: engine,
        scene: scene,
        logger: console,
        type: "root"
    });

    var rootContainer = BabylonJSRenderer.createContainer(rootNode);

    var startLoop = function () {
        var loopStarted = false;
        return function () {
            if (!loopStarted) {
                loopStarted = true;
                engine.runRenderLoop(function () {
                    return scene.render();
                });
            }
        };
    }();

    var render = function render(Component) {
        BabylonJSRenderer.updateContainer(Component, rootContainer, null, function () {
            return startLoop();
        });
    };

    var dispose = function dispose() {};

    return {
        render: render,
        dispose: dispose
    };
};

module.exports = { createRenderer: createRenderer, elements: elements };

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var Node = __webpack_require__(4);
var BabylonJSRenderer = __webpack_require__(5);

module.exports = { BabylonJSRenderer: BabylonJSRenderer, Node: Node };

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEBUG = function DEBUG() {};

var Node = function () {
    // Stores all the children

    function Node(root, props) {
        _classCallCheck(this, Node);

        DEBUG("@@Node.constructor");
        this.root = root;
        this.props = props;
        this.children = [];
    }

    Node.prototype.appendChild = function appendChild(child) {
        DEBUG("@@Node.appendChild", { child: child });
        this.children.push(child);
    };

    Node.prototype.removeChild = function removeChild(child, a, b) {
        DEBUG("@@Node.removeChild", { child: child, a: a, b: b });
        var index = this.children.indexOf(child);
        this.children.slice(index, 1);
    };

    return Node;
}();

module.exports = Node;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 1. evetns
// 1.1 warning message event doesn't exist
// 1.2 not recreate the component if the handler hasn't changed
// 2. compose properties
// 3. re-creatiing babylon component?
// 3.1 as it for now just throws an Error

// const babylonjsFactoryComponent = require("./babylonjs-factory-component");
var ErrorNotImplemented = function (_Error) {
    _inherits(ErrorNotImplemented, _Error);

    function ErrorNotImplemented() {
        _classCallCheck(this, ErrorNotImplemented);

        return _possibleConstructorReturn(this, _Error.apply(this, arguments));
    }

    return ErrorNotImplemented;
}(Error);

// const React = require("react");

var ReactFiberReconciler = __webpack_require__(6);

var i = 0;
var buildFiberPath = function buildFiberPath(_ref) {
    var child = _ref.child,
        sibling = _ref.sibling;

    return [{ child: child, sibling: sibling }];
};

var debug_fiber = function debug_fiber(_ref2) {
    var fiber = _ref2.return;

    return { stateNode: fiber.stateNode, type: fiber.type, fiber: fiber };
};
var DEBUG = function DEBUG() {};
var mutation = {
    commitMount: function commitMount(instance /* : Instance */
    , type /* : string */
    , newProps /* : Props */
    , internalInstanceHandle /* : Object */
    ) /* : void */{
        DEBUG("-@@@MUTATION.commitMount", type,
        // {
        //     newProps,
        //     instance,
        //     internalInstanceHandle,
        // },
        // ...buildFiberPath(internalInstanceHandle),
        debug_fiber(internalInstanceHandle));
    },
    commitUpdate: function commitUpdate(instance /* : Instance */
    , updatePayload /* : Object */
    , type /* : string */
    , oldProps /* : Props */
    , newProps /* : Props */
    , internalInstanceHandle /* : Object */
    ) /* : void */{
        DEBUG("+@@@MUTATION.commitUpdate", type,
        // {
        //     updatePayload,
        //     oldProps,
        //     newProps,
        //     instance,
        //     internalInstanceHandle,
        // },
        debug_fiber(internalInstanceHandle));

        if (instance.cmp && instance.cmp.updateProps) {
            instance.cmp.updateProps(updatePayload);
            return;
        }

        var rootContext = updatePayload.rootContext,
            hostContext = updatePayload.hostContext;

        Object.keys(newProps).filter(function (key) {
            return instance[key] && typeof instance[key] === "function";
        }).forEach(function (propertySetter) {
            instance[propertySetter](rootContext, hostContext, instance.cmp, newProps, oldProps);
        });
    },
    appendChild: function appendChild(parentInstance /* : Instance  | Container*/
    , child /* : Instance | TextInstance */
    ) /* : void */{
        DEBUG("+@@@MUTATION.appendChild " + child.type + " into => " + parentInstance.type, {
            parentInstance: parentInstance,
            child: child
        });
        parentInstance.addChild(child);
        // if (parentInstance.appendChild) {
        //     parentInstance.appendChild(child);
        // } else {
        //     parentInstance.babylonJSStuff = child;
        // }
    },
    appendChildToContainer: function appendChildToContainer(parentInstance /* : Container */
    , child /* : Instance | TextInstance*/
    ) /* : void */{
        DEBUG("-@@@MUTATION.appendChildToContainer", { parentInstance: parentInstance, child: child });
    },
    insertBefore: function insertBefore(parentInstance /* : Instance */
    , child /* : Instance | TextInstance*/
    , beforeChild /* : Instance | TextInstance*/
    ) /* : void */{
        DEBUG("-@@@MUTATION.insertBefore", {
            parentInstance: parentInstance,
            child: child,
            beforeChild: beforeChild
        });
        // noop
    },
    insertInContainerBefore: function insertInContainerBefore(parentInstance /* : Container */
    , child /* : Instance  | TextInstance*/
    , beforeChild /* : Instance | TextInstance*/
    ) /* : void */{
        DEBUG("-@@@MUTATION.insertInContainerBefore");
    },
    removeChild: function removeChild(parentInstance /* : Instance */
    , child /* : Instance  | TextInstance*/
    ) /* : void */{
        DEBUG("+@@@MUTATION.removeChild", child);
        parentInstance.removeChild(child);
    },
    removeChildFromContainer: function removeChildFromContainer(parentInstance /* : Container */
    , child /* : Instance  | TextInstance*/
    ) /* : void */{
        DEBUG("-@@@MUTATION.removeChildFromContainer");
    }
};

var BabylonJSRenderer = ReactFiberReconciler({
    mutation: mutation,
    useSyncScheduling: true,
    getPublicInstance: function getPublicInstance(instance) {
        DEBUG("@@BabylonJSRenderer.getPublicInstance");
        return instance;
    },
    getRootHostContext: function getRootHostContext(container) {
        DEBUG("BabylonJSRenderer.getRootHostContext", container.props, container.children);
        return Object.assign({ iAmTheHost: true }, container.props);
    },
    getChildHostContext: function getChildHostContext(parentContext, type /* : string */, rootContainer) {
        var _Object$assign;

        i++;
        DEBUG("BabylonJSRenderer.getChildHostContext-" + i + "}", {
            parentContext: parentContext,
            type: type,
            rootContainer: rootContainer
        });
        return Object.assign((_Object$assign = {}, _Object$assign["childHostContext" + i] = "childddddd", _Object$assign), parentContext, { type: type, rootContainer: rootContainer });
    },


    now: function now() {
        return Date.now();
    },

    createInstance: function createInstance(type /* : string */
    , props /* : Props */
    , rootContainerInstance /* : Container */
    , hostContext /* : {} */
    , internalInstanceHandle /* : Object */
    ) /* : Instance */{
        DEBUG.apply(undefined, ["BabylonJSRenderer.createInstance", {
            type: type,
            props: props,
            rootContainerInstance: rootContainerInstance,
            hostContext: hostContext,
            internalInstanceHandle: internalInstanceHandle
        }].concat(buildFiberPath(internalInstanceHandle)));

        var ele = createElement(rootContainerInstance, hostContext, type, props);

        if (ele.cmp) {
            // ele.dispose = () => DEBUG('************');
            ele.dispose = function () {
                return ele.cmp.dispose();
            };
        }
        return ele;
    },


    // at this stage all children were created and already had the `finalizeInitialChildren` executed
    // 1. when a component's created it's possible to set some default values
    // 2. also some actions, such as setting focus
    // 3. if it returns true, eventually it will trigger a commitMount
    // 4. another thing(if not the most important) you should set the properties in your component
    finalizeInitialChildren: function finalizeInitialChildren(instance /* : Instance */
    , type /* : string */
    , props /* : Props */
    , rootContainerInstance /* : Container */
    ) /* : boolean */{
        DEBUG("BabylonJSRenderer.finalizeInitialChildren", {
            type: type,
            props: props,
            instance: instance,
            rootContainerInstance: rootContainerInstance
        });
        return true;
    },
    appendInitialChild: function appendInitialChild(parentInstance /* : Instance */
    , child /* : Instance  | TextInstance*/
    ) /* : void */{
        DEBUG("+BabylonJSRenderer.appendInitialChild " + child.type + " into => " + parentInstance.type, {
            parentInstance: parentInstance,
            child: child
        });
        parentInstance.addChild(child);
        // if (parentInstance.appendChild) {
        //     parentInstance.appendChild(child);
        // } else {
        //     parentInstance.babylonJSStuff = child;
        // }
    },


    // decides if there is any update to be done
    // if there is no change to apply, then just returns null
    // otherwise to make your life easier, calculate what needs to be changed and return it
    // it's result will be passed to `mutation.commitUpdate` as `updatePayload` (2nd parameter)
    prepareUpdate: function prepareUpdate(instance /* : Instance */
    , type /* : string */
    , oldProps /* : Props */
    , newProps /* : Props */
    , rootContainerInstance /* : Container */
    , hostContext /* : {} */
    ) /* : null  | Object*/{
        DEBUG("BabylonJSRenderer.prepareUpdate", {
            type: type,
            instance: instance,
            oldProps: oldProps,
            newProps: newProps
        });
        // if (arePropsEqual(oldProps, newProps)) {
        //     return newProps;
        // }

        return newProps;
    },

    // **********************************
    // hooks whenever an update happens
    // **********************************
    prepareForCommit: function prepareForCommit() {
        DEBUG("-BabylonJSRenderer.prepareForCommit");
        // noop
    },
    resetAfterCommit: function resetAfterCommit() {
        DEBUG("-BabylonJSRenderer.resetAfterCommit");
        // noop
    },


    // **********************************
    // as it doesn't support pure text content....
    // **********************************
    // eslint-disable-next-line no-unused-vars
    shouldSetTextContent: function shouldSetTextContent(type /* : string */
    , props /* : Props*/
    ) /*:  boolean*/{
        return false;
    },

    // eslint-disable-next-line no-unused-vars
    resetTextContent: function resetTextContent(instance /* : Instance*/) /*:  void*/{
        throw new ErrorNotImplemented();
    },
    createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext,
    // eslint-disable-next-line no-unused-vars
    internalInstanceHandle) {
        throw new ErrorNotImplemented();
    },
    commitTextUpdate: function commitTextUpdate(textInstance /* : TextInstance */
    , oldText /* : string */
    , newText /* : string */
    ) /* : void */{
        throw new ErrorNotImplemented();
    }
}
// **********************************
// **********************************
);

BabylonJSRenderer.injectIntoDevTools({
    bundleType: 0, // 0 for PROD, 1 for DEV
    version: "0.1.0", // version for your renderer
    rendererPackageName: "babylon3d" // package name
});

module.exports = BabylonJSRenderer;

function TmpNode(values) {
    var _this2 = this;

    Object.keys(values).forEach(function (key) {
        return _this2[key] = values[key];
    });
    this.children = [];

    this.addChild = function (item) {
        this.children.push(item);
        item.parent = this;
    };

    this.removeChild = function (child) {
        while (child.children.length > 0) {
            child.removeChild(child.children[child.children.length - 1]);
        }var index = this.children.indexOf(child);
        if (index >= 0) {
            this.children.splice(index, 1);
        }
        if (child.dispose) {
            child.dispose();
        }
    };

    this.dispose = function () {
        if (this.cmp && this.cmp.dispose) {
            this.cmp.dispose();
        }
    };
}

function createElement(rootContext, parentContext, type, props) {
    var ele = new TmpNode({ type: type, props: props });

    if (rootContext.props.elements.byType[type]) {
        ele.cmp = rootContext.props.elements.byType[type](parentContext, props);
        return ele;
    }

    return ele;
}

// eslint-disable-next-line no-unused-vars
function processProps(instance /* : number */
, props /* : Props*/
) /*:  Object*/{
    var propsPayload = {};
    for (var key in props) {
        if (key === "children") {
            // Skip special case.
            continue;
        }
        var value = props[key];
        if (typeof value === "function") {
            value = {
                style: "rt-event",
                event: key,
                tag: instance
            };
        }
        propsPayload[key] = value;
    }
    return propsPayload;
}

// eslint-disable-next-line no-unused-vars
function arePropsEqual(oldProps /* : Props */
, newProps /* : Props*/
) /*:  boolean*/{
    for (var key in newProps) {
        if (key === "children") {
            // Skip special case.
            continue;
        }

        if (newProps[key] !== oldProps[key]) {
            return false;
        }
    }

    for (var _key in oldProps) {
        if (_key === "children") {
            // Skip special case.
            continue;
        }
        if (!(_key in newProps)) {
            return false;
        }
    }
    return true;
}

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

var ComponentManager = function ComponentManager() {
    var _lastId = 0;
    var _cache = {};
    var validateId = function validateId(componentId) {
        if (!componentId) {
            throw new Error("No id was provided");
        }

        var id = parseInt(componentId);

        if (!id || id > _lastId) {
            throw new Error("Invalid id");
        }
    };

    var newId = function newId() {
        return (++_lastId).toString();
    };
    var save = function save(componentId, component) {
        validateId(componentId);
        if (component) {
            _cache[componentId] = component;
        } else {
            delete _cache[componentId];
        }
    };
    var get = function get(componentId) {
        validateId(componentId);
        return _cache[componentId];
    };

    return {
        newId: newId,
        save: save,
        get: get
    };
};

module.exports = { create: ComponentManager };

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(9),
    compose = _require.compose;

var propertyUpdater = __webpack_require__(10);

var styles = {
    standardMaterial: function standardMaterial(props) {
        return { type: "standardMaterial", props: props };
    },
    shaderMaterial: function shaderMaterial(props) {
        return { type: "shaderMaterial", props: props };
    },
    texture: function texture(props) {
        return { type: "texture", props: props };
    },
    cubeTexture: function cubeTexture(props) {
        return { type: "cubeTexture", props: props };
    }
};

var fromPairs = function fromPairs(arr) {
    return arr.reduce(function (obj, _ref) {
        var _Object$assign;

        var key = _ref[0],
            value = _ref[1];
        return Object.assign(obj, (_Object$assign = {}, _Object$assign[key] = value, _Object$assign));
    }, {});
};

var byType = fromPairs([__webpack_require__(11), __webpack_require__(12), __webpack_require__(13), __webpack_require__(14), __webpack_require__(15), __webpack_require__(16), __webpack_require__(17), __webpack_require__(18), __webpack_require__(19), __webpack_require__(20)].map(function (_ref2) {
    var type = _ref2.type,
        props = _ref2.props,
        createComponent = _ref2.createComponent;
    return [type, compose(type, { props: props, createComponent: createComponent }, propertyUpdater(type, props))];
}));

module.exports = { styles: styles, byType: byType };

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var equals = function equals(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }

    if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === "object" && (typeof b === "undefined" ? "undefined" : _typeof(b)) === "object") {
        for (var key in a) {
            if (equals(a[key], b[key]) === false) {
                return false;
            }
        }

        for (var _key in b) {
            if (equals(a[_key], b[_key]) === false) {
                return false;
            }
        }

        return true;
    }

    return a === b;
};

var clone = function clone(obj) {
    if (Array.isArray(obj)) {
        return obj.slice(0);
    }

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object") {
        return obj;
    }

    var newObj = Object.assign({}, obj);

    for (var key in obj) {
        newObj[key] = clone(obj[key]);
    }

    return newObj;
};

var validateComponent = function validateComponent(type, definition, updater) {
    if (!type) {
        throw new Error("Component's type is required");
    }

    if (!definition) {
        throw new Error("Component's definition is required");
    }

    if (!definition.createComponent) {
        throw new Error("Component's definition's must have a property createComponent");
    }

    if (!updater) {
        throw new Error("Updater is required");
    }
};

var shouldCreateNewComponent = function shouldCreateNewComponent(propsDefinitions) {
    var defs = Object.keys(propsDefinitions).filter(function (def) {
        return propsDefinitions[def].newComponentRequired;
    }).reduce(function (acc, key) {
        var _Object$assign;

        return Object.assign(acc, (_Object$assign = {}, _Object$assign[key] = true, _Object$assign));
    }, {});

    return function (props, currentProps) {
        for (var prop in props) {
            if (defs[prop] && !equals(currentProps[prop], props[prop])) {
                return true;
            }
        }
        return false;
    };
};

var compose = function compose(type, definition, updater) {
    validateComponent(type, definition, updater);

    var definitionProps = Object.assign({}, definition.props);

    var requireNewComponent = shouldCreateNewComponent(definitionProps);

    var creator = function creator(context, providedProps) {
        var props = clone(providedProps);

        var componentId = void 0;
        var baseComponent = void 0;

        var getComponent = function getComponent() {
            return baseComponent;
        };
        var internalCreateComponent = function internalCreateComponent() {
            var tmpProps = clone(props);
            if (baseComponent) {
                baseComponent.dispose();
            }
            baseComponent = definition.createComponent(context, tmpProps);
        };

        internalCreateComponent();

        var instance = {
            getComponent: getComponent,
            updateProps: function updateProps(values) {
                var createNewComponent = requireNewComponent(values, props);

                Object.assign(props, clone(values));

                if (createNewComponent === true) {
                    internalCreateComponent();
                    return;
                }
                updater(context, getComponent(), clone(values), componentId);
            },
            dispose: function dispose() {
                return getComponent().dispose();
            }
        };

        componentId = context.componentManager.newId(instance);
        updater(context, getComponent(), clone(props), componentId);
        return instance;
    };

    creator.type = type;

    return creator;
};

module.exports = { compose: compose };

/***/ }),
/* 10 */
/***/ (function(module, exports) {

var propertyUpdater = function propertyUpdater(type, propsDefinition) {
    return function (context, component, props, componentId) {
        Object.keys(props).forEach(function (propName) {
            if (!propsDefinition[propName]) {
                context.logger.warn("property [" + propName + "] is not defined for the component <" + type + ">");
                return;
            }

            if (propsDefinition[propName].newComponentRequired === true) {
                return;
            }

            var _propsDefinition$prop = propsDefinition[propName],
                transformer = _propsDefinition$prop.transformer,
                setter = _propsDefinition$prop.setter;


            var value = void 0;
            if (transformer) {
                if (transformer.needLastReturned) {
                    var keyComponent = componentId + "::" + propName;
                    value = transformer(context, props[propName], context.componentManager.get(keyComponent));
                    context.componentManager.save(keyComponent, value);
                } else {
                    value = transformer(context, props[propName]);
                }
            } else {
                value = props[propName];
            }

            setter(component, value);
        });
    };
};

module.exports = propertyUpdater;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var transformers = __webpack_require__(1);
var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref) {
    var scene = _ref.scene;

    return scene;
};

var props = {
    clearColor: {
        setter: setters.property("clearColor"),
        transformer: transformers.vector3
    },
    ambientColor: {
        setter: setters.property("ambientColor"),
        transformer: transformers.vector3
    }

};

var scene = { type: "scene", createComponent: createComponent, props: props };

module.exports = scene;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.Mesh.CreateBox(props.name, props.size, scene);
    return component;
};

var props = {
    size: { newComponentRequired: true },
    infiniteDistance: {
        setter: setters.property("infiniteDistance")
    },
    width: { setter: setters.property("width") },
    height: { setter: setters.property("height") },
    subdivisions: { setter: setters.property("subdivisions") },
    material: {
        setter: setters.propertyFromComponent("material"),
        transformer: transformers.component
    },
    position: {
        setter: setters.property("position"),
        transform: transformers.vector3
    }
};

var box = { type: "box", createComponent: createComponent, props: props };
module.exports = box;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = BABYLON.Mesh.CreateGround(props.name, props.width, props.height, props.subdivisions, scene);
    return component;
};

var props = {
    width: { newComponentRequired: true },
    height: { newComponentRequired: true },
    subdivisions: { newComponentRequired: true },
    material: {
        setter: setters.propertyFromComponent("material"),
        transformer: transformers.component
    },

    position: {
        setter: setters.property("position"),
        transformer: transformers.vector3
    }
};

var ground = { type: "ground", createComponent: createComponent, props: props };
module.exports = ground;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = BABYLON.Mesh.CreateSphere(props.name, props.segments, props.diameter, scene);
    return component;
};

var props = {
    segments: { newComponentRequired: true },
    diameter: { newComponentRequired: true },
    infiniteDistance: { setter: setters.property("infiniteDistance") },
    position: {
        setter: setters.property("position"),
        transformer: transformers.vector3
    },
    material: {
        setter: setters.propertyFromComponent("material"),
        transformer: transformers.component
    }
};

var sphere = { type: "sphere", createComponent: createComponent, props: props };
module.exports = sphere;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var transformers = __webpack_require__(1);
var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.FreeCamera(props.name, new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(props.position)))(), scene);
    scene.activeCamera = component;
    if (props.defaultTarget) {
        component.setTarget(new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(props.defaultTarget)))());
    }
    return component;
};

var props = {
    position: { newComponentRequired: true },
    defaultTarget: { newComponentRequired: true },
    target: {
        setter: function setter(component, value) {
            return component.setTarget(value);
        },
        transformer: transformers.vector3
    },
    attachControl: {
        setter: setters.apply,
        transformer: function transformer(context, value) {
            if (value === true) {
                return function (component) {
                    return component.attachControl(context.canvas, true);
                };
            }
            return function (component) {
                return component.detachControl(context.canvas);
            };
        }
    }
};

var freeCamera = { type: "freeCamera", createComponent: createComponent, props: props };

module.exports = freeCamera;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.HemisphericLight(props.name, new (Function.prototype.bind.apply(BABYLON.Vector3, [null].concat(props.target)))(), scene);
    return component;
};

var props = {
    target: { newComponentRequired: true },
    intensity: { setter: setters.property("intensity") }
};

var hemisphericLight = { type: "hemisphericLight", createComponent: createComponent, props: props };
module.exports = hemisphericLight;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.ShaderMaterial(props.name, scene, props.shaderPath, {
        attributes: Array.from(props.attributes),
        uniforms: Array.from(props.uniforms)
    });
    return component;
};

var props = {
    shaderPath: { newComponentRequired: true },
    attributes: { newComponentRequired: true },
    uniforms: { newComponentRequired: true },

    diffuseColor: {
        setter: setters.property("diffuseColor"),
        transformer: transformers.vector3
    },
    backFaceCulling: { setter: setters.property("backFaceCulling") },

    width: { setter: setters.setFloat("width") },
    height: { setter: setters.setFloat("height") },
    boxSize: { setter: setters.setFloat("boxSize") },
    edgeColor: {
        setter: setters.setVector4("edgeColor"),
        transformer: transformers.vector4
    },
    hue: {
        setter: setters.setVector4("hue"),
        transformer: transformers.vector4
    },

    tileTex: {
        setter: setters.setTexture("tileTex"),
        transformer: transformers.component
    }
};

var shaderMaterial = {
    superTypes: ["material"],
    type: "shaderMaterial",
    createComponent: createComponent,
    props: props
};

module.exports = shaderMaterial;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);
var transformers = __webpack_require__(1);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.StandardMaterial(props.name, scene);
    return component;
};

var props = {
    backFaceCulling: { setter: setters.property("backFaceCulling") },
    diffuseColor: {
        setter: setters.property("diffuseColor"),
        transformer: transformers.vector3
    },

    specularColor: {
        setter: setters.property("specularColor"),
        transformer: transformers.vector3
    },
    emissiveColor: {
        setter: setters.property("emissiveColor"),
        transformer: transformers.vector3
    },
    ambientColor: {
        setter: setters.property("ambientColor"),
        transformer: transformers.vector3
    },

    reflectionTexture: {
        setter: setters.propertyFromComponent("reflectionTexture"),
        transformer: transformers.component
    }
};

var standardMaterial = {
    superTypes: ["material"],
    type: "standardMaterial",
    createComponent: createComponent,
    props: props
};

module.exports = standardMaterial;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.Texture(props.url, scene);
    return component;
};

var props = {
    url: { newComponentRequired: true }
};

var texture = {
    superTypes: ["texture"],
    type: "texture",
    createComponent: createComponent,
    props: props
};

module.exports = texture;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var setters = __webpack_require__(0);

var createComponent = function createComponent(_ref, props) {
    var BABYLON = _ref.BABYLON,
        scene = _ref.scene;

    var component = new BABYLON.CubeTexture(props.url, scene);
    return component;
};

var props = {
    url: { newComponentRequired: true },
    coordinatesMode: {
        setter: setters.property("coordinatesMode")
    }
};

var cubeTexture = {
    superTypes: ["cubeTexture"],
    type: "cubeTexture",
    createComponent: createComponent,
    props: props
};

module.exports = cubeTexture;

/***/ })
/******/ ]);
});
//# sourceMappingURL=react-babylon-3d.min.js.map